/*******************************************************************************
 * TriggerSplashGeowater generated by Eliot.UELib using UELib.CLI.
 * Eliot.UELib Â© 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class TriggerSplashGeowater extends Triggers
	collapsecategories
	notplaceable
	hidecategories(Filter,Interactivity,Karma,Lighting,Networking,Sound);

var() noexport name TagEnable "Call this to enable the effect. You can also simply trigger the actor toggle whether it's currently splashing.";
var() noexport name TagDisable "Call this to disable the effect.";
var() noexport Vector SplashLocationVariance "Randomly select within this many units around the actor to perform the splash.";
var() noexport float SplashRadius "Radius of the water splash influence.";
var() noexport float SplashRadiusVariance "Variance of the splash radius.";
var() noexport float SplashStrength "Strength of the water splash.";
var() noexport float SplashStrengthVariance "Variance of the splash strength.";
var() noexport float LoopDelay "Amount of time to delay before splashing again. Delay can not be less than or equal to 0 in order to loop.";
var() noexport float LoopDelayVariance "Amount to vary the delay by. Can't be more than  2 * Delay.";
var() noexport int LoopCountMax "Number of times to loop. If 0, never loop. If -1, loop forever.";
var() noexport int LoopCountMaxVariance "Variance of the number of times to loop. Can't be more than 2 * LoopCountMax";
var() noexport bool bOnlyFindWaterOnSpawn "If true, then it only checks for the water when it spawns in and never again.";
var int ActualLoopCountMax;
var int LoopCount;
var bool bCurrentlyLooping;
var GeoWater Water;

function bool VerifySelf()
{
	// End:0x23
	if(__NFUN_200__(LoopDelay, float(0)))
	{
		LoopDelay = float(__NFUN_189__(int(__NFUN_211__(LoopDelay)), int(0.001)));
	}
	// End:0x53
	if(__NFUN_201__(LoopDelay, float(0)))
	{
		// End:0x53
		if(__NFUN_201__(__NFUN_196__(LoopDelayVariance, float(2)), LoopDelay))
		{
			LoopDelayVariance = __NFUN_195__(LoopDelay, float(2));
		}
	}
	// End:0x80
	if(__NFUN_170__(LoopCountMax, 0))
	{
		// End:0x80
		if(__NFUN_170__(__NFUN_163__(LoopCountMaxVariance, 2), LoopCountMax))
		{
			LoopCountMaxVariance = __NFUN_162__(LoopCountMax, 2);
		}
	}
	return super(Actor).VerifySelf();
	return;
}

function PostVerifySelf()
{
	super(Actor).PostVerifySelf();
	__NFUN_718__('EnableSplashing', TagEnable);
	__NFUN_718__('DisableSplashing', TagDisable);
	// End:0x99
	if(bOnlyFindWaterOnSpawn)
	{
		// End:0x70
		if(__NFUN_148__(__NFUN_340__(PhysicsVolume, none), __NFUN_340__(PhysicsVolume.GeoWaterActor, none)))
		{
			Water = PhysicsVolume.CheckForGeoWater(Location, SplashRadius);			
		}
		else
		{
			Water = GeoWater(__NFUN_725__(class'GeoWater', Location, __NFUN_232__(SplashRadius, SplashRadius, SplashRadius)));
		}
	}
	return;
}

final function PerformSplash()
{
	local Vector ActualSplashLocation;
	local float ActualSplashStrength, ActualSplashRadius;

	ActualSplashLocation = __NFUN_232__(__NFUN_226__(Location.X, SplashLocationVariance.X), __NFUN_226__(Location.Y, SplashLocationVariance.Y), __NFUN_226__(Location.Z, SplashLocationVariance.Z));
	ActualSplashRadius = __NFUN_226__(SplashRadius, SplashRadiusVariance);
	ActualSplashStrength = __NFUN_226__(SplashStrength, SplashStrengthVariance);
	// End:0xE9
	if(__NFUN_145__(bOnlyFindWaterOnSpawn))
	{
		// End:0xC0
		if(__NFUN_148__(__NFUN_340__(PhysicsVolume, none), __NFUN_340__(PhysicsVolume.GeoWaterActor, none)))
		{
			Water = PhysicsVolume.CheckForGeoWater(ActualSplashLocation, ActualSplashRadius);			
		}
		else
		{
			Water = GeoWater(__NFUN_725__(class'GeoWater', ActualSplashLocation, __NFUN_232__(ActualSplashRadius, ActualSplashRadius, ActualSplashRadius)));
		}
	}
	// End:0x111
	if(__NFUN_340__(Water, none))
	{
		Water.__NFUN_1115__(ActualSplashLocation, ActualSplashStrength, ActualSplashRadius);
	}
	// End:0x181
	if(__NFUN_148__(__NFUN_174__(ActualLoopCountMax, 0), __NFUN_206__(LoopDelay, float(0))))
	{
		// End:0x14D
		if(__NFUN_169__(ActualLoopCountMax, 0))
		{
			__NFUN_605__(__NFUN_226__(LoopDelay, LoopDelayVariance), false, 'PerformSplash');			
		}
		else
		{
			// End:0x17B
			if(__NFUN_169__(LoopCount, ActualLoopCountMax))
			{
				__NFUN_184__(LoopCount);
				__NFUN_605__(__NFUN_226__(LoopDelay, LoopDelayVariance), false, 'PerformSplash');				
			}
			else
			{
				TriggerFunc_DisableSplashing();
			}
		}
	}
	return;
}

event Trigger(Actor Other, Pawn EventInstigator)
{
	super(Actor).Trigger(Other, EventInstigator);
	// End:0x22
	if(bCurrentlyLooping)
	{
		TriggerFunc_DisableSplashing();		
	}
	else
	{
		TriggerFunc_EnableSplashing();
	}
	return;
}

final function TriggerFunc_EnableSplashing()
{
	TriggerFunc_DisableSplashing();
	LoopCount = 0;
	// End:0x2D
	if(__NFUN_170__(LoopCountMax, 0))
	{
		ActualLoopCountMax = __NFUN_190__(LoopCountMax, LoopCountMaxVariance);		
	}
	else
	{
		ActualLoopCountMax = -1;
	}
	TickStyle = 2;
	bCurrentlyLooping = true;
	PerformSplash();
	return;
}

final function TriggerFunc_DisableSplashing()
{
	__NFUN_606__('PerformSplash');
	bCurrentlyLooping = false;
	TickStyle = 0;
	return;
}

defaultproperties
{
	bOnlyFindWaterOnSpawn=true
}