/*******************************************************************************
 * aFinalDecoration_Switches generated by Eliot.UELib using UELib.CLI.
 * Eliot.UELib Â© 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class aFinalDecoration_Switches extends dnUsableSomething
	abstract
	collapsecategories;

struct SwitchState
{
	var() noexport bool bAfterSequence "Don't do the changes until after the animation sequence has finished playing. Also disables the trigger ability until the animation is complete.";
	var noexport name Sequence "DEPRECATED PROPERTY... DON'T USE! Use SwitchAnimInfo instead.";
	var() noexport SAnimInfo SwitchAnimInfo "Animation information to play.";
	var() noexport SAnimInfo DisabledSwitchAnimInfo "Animation to play when disabled";
	var SSoundInfo Sound;
	var SSoundInfo DisabledSound;
	var() noexport name SoundName "Name of the VoicePack entry we want to use when enabled.";
	var() noexport name DisabledSoundName "Name of the VoicePack entry we want to use when disabled.";
	var() noexport array<SUpdateMaterialEx> SwitchSkins "Materials to swap out on the switch when this state is engaged.";
	var() noexport name PlayerAnim "Anim Controller name to execute on player";
	var() noexport name DisabledPlayerAnim "Anim Controller name to execute on player when switch is disabled";
	var() noexport array<SActorColor> SwitchActorColors "Actor colors to apply after the switch";
};

struct SSwitchUserState
{
	var() noexport string UsePhrase "UsePhrase to display in this state.";
	var() noexport float SwitchAgainTime "If this is greater than 0, then the switch will automatically go to the next state after the specified amount of time has passed. The switch is disabled during this time and unable to do anything until the time has expired.";
	var() noexport float SwitchPauseTime "Amount of time to pause after switching states before the switch can be hit again.";
	var() noexport name Event "Event to call when this state is engaged.";
};

var(SwitchInfo) noexport array<SwitchState> SwitchStates "The various states the switch can be in.";
var(SwitchInfo) noexport array<SSwitchUserState> SwitchUserStates "Events that this switch is supposed to fire off.";
var(SwitchInfo) noexport name SwitchID "A unique ID to identify groups of switches that should stay synched together.";
var(SwitchInfo) noexport localized string DisabledMessage "Message to display when this switch is disabled.";
var(SwitchInfo) noexport localized string PausedMessage "Message to display when the switch is currently just paused.";
var(SwitchInfo) noexport int CurrentIndex "Index of the state we start out in. Remember that this isn't the first state to occur when the actor is used... it's what state it is in CURRENTLY.";
var(SwitchInfo) noexport bool bAnimUser "Animate this user when using the switch";
var(SwitchInfo) noexport bool bLoop "If this is false, then when the switch gets to the last state in the list, it will not go back around to the start again.";
var(SwitchInfo) noexport bool bQueueSwitchAgainWhenDisabled "If the switch gets disabled while we are waiting to switch again, then if this is true, we'll switch ourselves immediately upon getting enabled again.";
var(SwitchInfo) noexport bool bShootable "Switch can be shot. Will act like it was used each time it is shot.";
var(SwitchInfo) noexport name SE_ToggleSwitchStatus "Calling this will toggle the switch from being Enabled/Disabled";
var(SwitchInfo) noexport name SE_SetEnabled "Triggering this event will enable the switch.";
var(SwitchInfo) noexport name SE_SetDisabled "Triggering this event will disable the switch.";
var bool bDisabledForever;
var bool bDisabled;
var bool bSwitching;
var bool bSynching;
var bool bPausing;
var bool bLastAnimWasStuck;
var bool bQueuedSwitch;
var int QueuedSynchState;
var int nUsable;

replication
{
	// Pos:0x000
	reliable if(__NFUN_173__(int(Role), int(ROLE_Authority)))
		ClientDecoAnim, ClientEndSwitch, 
		ClientSetUsePhrase, nUsable;
}

simulated function NU_nUsable(int Index)
{
	local int i;

	ClientSetUsePhrase(Index);
	i = __NFUN_166__(string(SwitchStates[Index].SwitchActorColors), 1);
	J0x25:

	// End:0x53 [Loop If]
	if(__NFUN_172__(i, 0))
	{
		__NFUN_602__(SwitchStates[Index].SwitchActorColors[i]);
		__NFUN_185__(i);
		// [Loop Continue]
		goto J0x25;
	}
	return;
}

simulated function PreBeginPlay()
{
	__NFUN_718__('ToggleSwitchStatus', SE_ToggleSwitchStatus);
	__NFUN_718__('SetEnabled', SE_SetEnabled);
	__NFUN_718__('SetDisabled', SE_SetDisabled);
	// End:0x39
	if(__NFUN_145__(bAnimUser))
	{
		ControlRemapperClass = none;
	}
	super.PreBeginPlay();
	return;
}

simulated function bool VerifySelf()
{
	local SAnimInfo AnimInfo;
	local int i;

	// End:0x7E
	if(__NFUN_173__(string(SwitchStates), 0))
	{
		InvalidAlert(__NFUN_302__(__NFUN_302__("Warning: ", string(self)), " has 0 switch states. Can't operate without at least one switch state. Removing self."));
		return false;
	}
	i = __NFUN_166__(string(SwitchStates), 1);
	J0x8D:

	// End:0x10F [Loop If]
	if(__NFUN_172__(i, 0))
	{
		AnimInfo = SwitchStates[i].SwitchAnimInfo;
		// End:0x105
		if(__NFUN_341__(AnimInfo.Animation, 'None'))
		{
			AnimInfo.Animation = SwitchStates[i].Sequence;
			// End:0x105
			if(SwitchStates[i].bAfterSequence)
			{
				SwitchStates[i].bAfterSequence = false;
			}
		}
		__NFUN_185__(i);
		// [Loop Continue]
		goto J0x8D;
	}
	return super(Actor).VerifySelf();
	return;
}

simulated function PostVerifySelf()
{
	super.PostVerifySelf();
	Synch(CurrentIndex);
	// End:0x21
	if(bStartupOff)
	{
		SetSwitchStatus(true);
	}
	return;
}

simulated function StartSelfOff()
{
	return;
}

final function Synch(int Index)
{
	// End:0x27
	if(__NFUN_145__(bSwitching))
	{
		bSynching = true;
		CurrentIndex = Index;
		StartSwitchState();		
	}
	else
	{
		QueuedSynchState = Index;
	}
	return;
}

simulated function TriggerFunc_ToggleSwitchStatus()
{
	ToggleSwitchStatus();
	return;
}

simulated function TriggerFunc_SetEnabled()
{
	SetSwitchStatus(false);
	return;
}

simulated function TriggerFunc_SetDisabled()
{
	SetSwitchStatus(true);
	return;
}

simulated event Trigger(Actor Other, Pawn EventInstigator)
{
	super(dnDecoration).Trigger(Other, EventInstigator);
	UsedNoRelevantPawnAnims(none, true);
	return;
}

simulated event TakeDamage(Pawn Instigator, float Damage, Vector DamageOrigin, Vector DamageDirection, class<DamageType> DamageType, optional name HitBoneName, optional Vector DamageStart)
{
	super(dnDecoration).TakeDamage(Instigator, Damage, DamageOrigin, DamageDirection, DamageType, HitBoneName, DamageStart);
	// End:0x8E
	if(__NFUN_148__(__NFUN_148__(__NFUN_148__(__NFUN_148__(bShootable, __NFUN_145__(bSwitching)), __NFUN_340__(Instigator, none)), Instigator.bIsPlayerPawn), __NFUN_150__(__NFUN_357__(DamageType, class'BulletDamage'), __NFUN_357__(DamageType, class'MeleeDamage'))))
	{
		UsedNoRelevantPawnAnims(none, true);
	}
	return;
}

simulated event Destroyed()
{
	super.Destroyed();
	SetSwitchStatus(true);
	bUsable = false;
	return;
}

final simulated function ToggleSwitchStatus()
{
	SetSwitchStatus(__NFUN_145__(bDisabled));
	return;
}

final simulated function SetSwitchStatus(bool bSwitchDisabled)
{
	bDisabled = bSwitchDisabled;
	SetUsePhrase();
	bUsable = __NFUN_145__(bDisabled);
	// End:0x5A
	if(__NFUN_148__(__NFUN_148__(__NFUN_148__(bQueuedSwitch, __NFUN_145__(SwitchIsDisabled())), __NFUN_145__(bPausing)), __NFUN_145__(bSwitching)))
	{
		UsedNoRelevantPawnAnims(none, true);
	}
	return;
}

simulated function bool SwitchIsDisabled()
{
	// End:0x0B
	if(MPRoundNotInProgress())
	{
		return true;
	}
	return __NFUN_150__(bDisabledForever, bDisabled);
	return;
}

simulated function bool CanAttachPawn(Pawn Attachee)
{
	local bool bHasRelevantAnims;

	// End:0x12
	if(__NFUN_145__(super.CanAttachPawn(Attachee)))
	{
		return false;
	}
	// End:0x2B
	if(__NFUN_150__(bSwitching, bPausing))
	{
		return false;		
	}
	else
	{
		// End:0x6A
		if(SwitchIsDisabled())
		{
			// End:0x65
			if(__NFUN_148__(bAnimUser, __NFUN_342__(SwitchStates[CurrentIndex].DisabledPlayerAnim, 'None')))
			{
				bHasRelevantAnims = true;				
			}
			else
			{
				return false;
			}			
		}
		else
		{
			IncrementSwitchState();
			bHasRelevantAnims = bAnimUser;
		}
	}
	// End:0x93
	if(__NFUN_145__(bHasRelevantAnims))
	{
		UsedNoRelevantPawnAnims(Attachee);
	}
	return bHasRelevantAnims;
	return;
}

final simulated function IncrementSwitchState()
{
	CurrentIndex = __NFUN_164__(__NFUN_165__(CurrentIndex, 1), string(SwitchStates));
	return;
}

final simulated function UsedNoRelevantPawnAnims(Pawn User, optional bool bIncrement)
{
	// End:0x0B
	if(SwitchIsDisabled())
	{
		return;
	}
	// End:0x1A
	if(bIncrement)
	{
		IncrementSwitchState();
	}
	// End:0x97
	if(__NFUN_340__(User, none))
	{
		User.HandQuickAction(SwitchStates[CurrentIndex].PlayerAnim);
		// End:0x97
		if(__NFUN_148__(__NFUN_148__(IsMP(), __NFUN_173__(int(Role), int(ROLE_Authority))), __NFUN_340__(DukePlayer(User), none)))
		{
			DukePlayer(User).ClientHandQuickAction(SwitchStates[CurrentIndex].PlayerAnim);
		}
	}
	StartSwitchState();
	// End:0xB1
	if(IsMP())
	{
		Instigator = User;
	}
	return;
}

final simulated function StartSwitchState()
{
	local aFinalDecoration_Switches SwitchDeco;

	bSwitching = true;
	bQueuedSwitch = false;
	// End:0x5D
	if(__NFUN_145__(bSynching))
	{
		TickStyle = 3;
		DecoPlayAnimEx(SwitchStates[CurrentIndex].SwitchAnimInfo);
		// End:0x5D
		if(__NFUN_148__(IsMP(), __NFUN_173__(int(Role), int(ROLE_Authority))))
		{
			ClientDecoAnim(CurrentIndex);
		}
	}
	// End:0xC9
	if(__NFUN_148__(__NFUN_342__(SwitchID, 'None'), __NFUN_145__(bSynching)))
	{
		// End:0xC8
		foreach __NFUN_747__(class'aFinalDecoration_Switches', SwitchDeco)
		{
			// End:0xC7
			if(__NFUN_148__(__NFUN_341__(SwitchDeco.SwitchID, SwitchID), __NFUN_340__(SwitchDeco, self)))
			{
				SwitchDeco.Synch(CurrentIndex);
			}			
		}		
	}
	// End:0xF0
	if(__NFUN_150__(__NFUN_145__(SwitchStates[CurrentIndex].bAfterSequence), bSynching))
	{
		EndSwitchState();
	}
	return;
}

simulated delegate ClientDecoAnim(int cIdx)
{
	DecoPlayAnimEx(SwitchStates[cIdx].SwitchAnimInfo);
	return;
}

simulated function AnimEndActivity(int Channel, name AnimName)
{
	super(dnDecoration).AnimEndActivity(Channel, AnimName);
	// End:0x2A
	if(SwitchStates[CurrentIndex].bAfterSequence)
	{
		EndSwitchState();
	}
	return;
}

simulated function EndSwitchState()
{
	local SUpdateMaterialEx UpdateMaterialEx;
	local int i;

	TickStyle = default.TickStyle;
	i = __NFUN_166__(string(SwitchStates[CurrentIndex].SwitchSkins), 1);
	J0x25:

	// End:0x6D [Loop If]
	if(__NFUN_172__(i, 0))
	{
		UpdateMaterialEx = SwitchStates[CurrentIndex].SwitchSkins[i];
		__NFUN_741__(UpdateMaterialEx.Index, UpdateMaterialEx.NewMaterialEx);
		__NFUN_185__(i);
		// [Loop Continue]
		goto J0x25;
	}
	i = __NFUN_166__(string(SwitchStates[CurrentIndex].SwitchActorColors), 1);
	J0x87:

	// End:0xB5 [Loop If]
	if(__NFUN_172__(i, 0))
	{
		__NFUN_602__(SwitchStates[CurrentIndex].SwitchActorColors[i]);
		__NFUN_185__(i);
		// [Loop Continue]
		goto J0x87;
	}
	// End:0xDD
	if(__NFUN_148__(__NFUN_145__(bLoop), __NFUN_173__(CurrentIndex, __NFUN_166__(string(SwitchStates), 1))))
	{
		bDisabledForever = true;
	}
	SetUsePhrase();
	// End:0x126
	if(__NFUN_145__(bSynching))
	{
		// End:0x126
		if(__NFUN_148__(__NFUN_145__(bLastAnimWasStuck), __NFUN_170__(string(SwitchUserStates), CurrentIndex)))
		{
			GlobalTrigger(SwitchUserStates[CurrentIndex].Event, Instigator);
		}
	}
	// End:0x13A
	if(IsMP())
	{
		ClientEndSwitch(CurrentIndex);
	}
	// End:0x14E
	if(__NFUN_145__(SwitchIsDisabled()))
	{
		TryToPauseSwitch();		
	}
	else
	{
		TryToCompleteSwitching();
	}
	return;
}

simulated delegate ClientEndSwitch(int cIdx)
{
	local int i;
	local SUpdateMaterialEx UpdateMaterialEx;

	i = __NFUN_166__(string(SwitchStates[cIdx].SwitchSkins), 1);
	J0x1A:

	// End:0x62 [Loop If]
	if(__NFUN_172__(i, 0))
	{
		UpdateMaterialEx = SwitchStates[cIdx].SwitchSkins[i];
		__NFUN_741__(UpdateMaterialEx.Index, UpdateMaterialEx.NewMaterialEx);
		__NFUN_185__(i);
		// [Loop Continue]
		goto J0x1A;
	}
	i = __NFUN_166__(string(SwitchStates[cIdx].SwitchActorColors), 1);
	J0x7C:

	// End:0xAA [Loop If]
	if(__NFUN_172__(i, 0))
	{
		__NFUN_602__(SwitchStates[cIdx].SwitchActorColors[i]);
		__NFUN_185__(i);
		// [Loop Continue]
		goto J0x7C;
	}
	return;
}

final simulated function TryToPauseSwitch()
{
	bPausing = true;
	SetUsePhrase();
	// End:0x56
	if(__NFUN_148__(__NFUN_170__(string(SwitchUserStates), CurrentIndex), __NFUN_201__(SwitchUserStates[CurrentIndex].SwitchPauseTime, 0)))
	{
		__NFUN_607__(SwitchUserStates[CurrentIndex].SwitchPauseTime, false, 'TryToSwitchAgain');		
	}
	else
	{
		TryToSwitchAgain();
	}
	return;
}

final simulated function TryToSwitchAgain()
{
	// End:0x59
	if(__NFUN_148__(__NFUN_170__(string(SwitchUserStates), CurrentIndex), __NFUN_201__(SwitchUserStates[CurrentIndex].SwitchAgainTime, 0)))
	{
		// End:0x3D
		if(bQueueSwitchAgainWhenDisabled)
		{
			bQueuedSwitch = true;
		}
		__NFUN_607__(SwitchUserStates[CurrentIndex].SwitchAgainTime, false, 'SwitchAgainOver');		
	}
	else
	{
		TryToCompleteSwitching();
	}
	return;
}

final simulated function SwitchAgainOver()
{
	TryToCompleteSwitching();
	UsedNoRelevantPawnAnims(none, true);
	return;
}

final simulated function TryToCompleteSwitching()
{
	bPausing = false;
	bSynching = false;
	bSwitching = false;
	SetUsePhrase();
	// End:0x3B
	if(__NFUN_174__(QueuedSynchState, -1))
	{
		__NFUN_607__(1E-05, false, 'QueuedSynch');
	}
	return;
}

simulated function QueuedSynch()
{
	local int synchState;

	synchState = QueuedSynchState;
	QueuedSynchState = -1;
	Synch(synchState);
	return;
}

final simulated function SetUsePhrase()
{
	// End:0x47
	if(bDisabled)
	{
		bNoUseKeyInfo = true;
		UsePhrase = DisabledMessage;
		bForceUsePhrase = true;
		// End:0x44
		if(__NFUN_148__(IsMP(), __NFUN_173__(int(Role), int(ROLE_Authority))))
		{
			nUsable = 0;
		}		
	}
	else
	{
		// End:0x8E
		if(bPausing)
		{
			bNoUseKeyInfo = true;
			UsePhrase = PausedMessage;
			bForceUsePhrase = true;
			// End:0x8B
			if(__NFUN_148__(IsMP(), __NFUN_173__(int(Role), int(ROLE_Authority))))
			{
				nUsable = 1;
			}			
		}
		else
		{
			UsePhrase = default.UsePhrase;
			// End:0xBA
			if(__NFUN_148__(IsMP(), __NFUN_173__(int(Role), int(ROLE_Authority))))
			{
				nUsable = 2;
			}
		}
	}
	return;
}

simulated delegate ClientSetUsePhrase(int phrase)
{
	switch(phrase)
	{
		// End:0x1A
		case 0:
			UsePhrase = DisabledMessage;
			// End:0x42
			break;
		// End:0x2C
		case 1:
			UsePhrase = PausedMessage;
			// End:0x42
			break;
		// End:0x3F
		case 2:
			UsePhrase = default.UsePhrase;
			// End:0x42
			break;
		// End:0xFFFF
		default:
			break;
	}
	return;
}

final simulated function Switch_User_Animate()
{
	// End:0x4A
	if(SwitchIsDisabled())
	{
		bLastAnimWasStuck = true;
		User.SetUsableSomethingAnimation(SwitchStates[CurrentIndex].DisabledPlayerAnim);
		DecoPlayAnimEx(SwitchStates[CurrentIndex].DisabledSwitchAnimInfo);		
	}
	else
	{
		bLastAnimWasStuck = false;
		User.SetUsableSomethingAnimation(SwitchStates[CurrentIndex].PlayerAnim);
		StartSwitchState();
	}
	return;
}

simulated function AttachComplete()
{
	super.AttachComplete();
	// End:0x15
	if(bUseHomePose)
	{
		Switch_User_Animate();
	}
	return;
}

simulated function AttachPawnSuccess(Pawn Attachee, optional bool bForced)
{
	super.AttachPawnSuccess(Attachee, bForced);
	// End:0x22
	if(__NFUN_145__(bUseHomePose))
	{
		Switch_User_Animate();
	}
	return;
}

simulated function AnimCallback_UserReleased()
{
	super(InteractiveActor).AnimCallback_UserReleased();
	AnimCallback_UserDetached();
	return;
}

k2call simulated function PlayActivate(optional EventInfo EventParms)
{
	// End:0x23
	if(__NFUN_145__(bSynching))
	{
		FindAndPlaySound(SwitchStates[CurrentIndex].SoundName, 1);
	}
	return;
}

k2call simulated function PlayStuck(optional EventInfo EventParms)
{
	// End:0x23
	if(__NFUN_145__(bSynching))
	{
		FindAndPlaySound(SwitchStates[CurrentIndex].DisabledSoundName, 1);
	}
	return;
}

simulated event EnumerateRawAnimationSequences(out array<SAnimationEnumeration> References)
{
	local int i;

	super(dnDecoration).EnumerateRawAnimationSequences(References);
	i = 0;
	J0x12:

	// End:0xB6 [Loop If]
	if(__NFUN_169__(i, string(SwitchStates)))
	{
		// End:0x67
		if(__NFUN_342__(SwitchStates[i].SwitchAnimInfo.Animation, 'None'))
		{
			AddAnimationEnumeration(References, SwitchStates[i].SwitchAnimInfo.Animation, Mesh);
		}
		// End:0xAC
		if(__NFUN_342__(SwitchStates[i].DisabledSwitchAnimInfo.Animation, 'None'))
		{
			AddAnimationEnumeration(References, SwitchStates[i].DisabledSwitchAnimInfo.Animation, Mesh);
		}
		__NFUN_184__(i);
		// [Loop Continue]
		goto J0x12;
	}
	return;
}

event RegisterPrecacheComponents(PrecacheIndex PrecacheIndex)
{
	local int i, j;

	super.RegisterPrecacheComponents(PrecacheIndex);
	i = __NFUN_166__(string(SwitchStates), 1);
	J0x1A:

	// End:0x135 [Loop If]
	if(__NFUN_172__(i, 0))
	{
		PrecacheIndex.__NFUN_1281__(SwitchStates[i].PlayerAnim);
		PrecacheIndex.__NFUN_1284__(Mesh, SwitchStates[i].SwitchAnimInfo.Animation);
		PrecacheIndex.__NFUN_1284__(Mesh, SwitchStates[i].DisabledSwitchAnimInfo.Animation);
		PrecacheIndex.__NFUN_1277__(VoicePack, SwitchStates[i].SoundName);
		PrecacheIndex.__NFUN_1277__(VoicePack, SwitchStates[i].DisabledSoundName);
		j = __NFUN_166__(string(SwitchStates[i].SwitchSkins), 1);
		J0xEE:

		// End:0x12B [Loop If]
		if(__NFUN_172__(j, 0))
		{
			PrecacheIndex.__NFUN_1269__(SwitchStates[i].SwitchSkins[j].NewMaterialEx);
			__NFUN_185__(j);
			// [Loop Continue]
			goto J0xEE;
		}
		__NFUN_185__(i);
		// [Loop Continue]
		goto J0x1A;
	}
	return;
}

defaultproperties
{
	DisabledMessage="<?int?dnDecorations.aFinalDecoration_Switches.DisabledMessage?>"
	PausedMessage="<?int?dnDecorations.aFinalDecoration_Switches.PausedMessage?>"
	bLoop=true
	bQueueSwitchAgainWhenDisabled=true
	QueuedSynchState=-1
	UserMountPrefab=(bDontActuallyMount=false,bHideable=false,bIndependentRotation=false,bIndependentLocation=false,bMatchParentLocation=false,bMatchParentRotation=false,bSurviveDismount=true,bDontScaleByDrawScale=true,bScaleByDrawScaleNonDefault=false,bTransformDrawScale3DChange=false,bTakeParentTag=false,bTransferToCorpse=false,bDontSetOwner=true,MountParentTag=None,DrawScaleOverride=0,AppendToTag=None,ForceTag=None,ForceEvent=None,MountMeshItem=None,MountOrigin=(X=1.291717E-41,Y=2.802813E-17,Z=0),Z=-50)
	ForwardRotationOffset=(Pitch=8709,Yaw=571080704,Roll=32768)
	bStandardUseRestriction=false
	DetachUserSoundName=None
	HealthPrefab=0
	ShrunkUseStyle=1
	bNeverMeshAccurate=true
	bNoNativeTick=true
	bTickOnlyRecent=false
	bTickOnlyZoneRecent=false
	PlacementZOffset=64
	TickStyle=0
	TransientSoundRadius=128
	TransientSoundInnerRadius=64
	VoicePack='SoundConfig.Interactive.VoicePack_Switches'
}