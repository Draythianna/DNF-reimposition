/*******************************************************************************
 * SpiralStairBuilder generated by Eliot.UELib using UELib.CLI.
 * Eliot.UELib Â© 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class SpiralStairBuilder extends BrushBuilder;

var() int InnerRadius;
var() int StepWidth;
var() int StepHeight;
var() int StepThickness;
var() int NumStepsPer360;
var() int NumSteps;
var() name GroupName;
var() bool SlopedCeiling;
var() bool SlopedFloor;
var() bool CounterClockwise;

function BuildCurvedStair(int Direction)
{
	local Rotator RotStep, NewRot;
	local Vector vtx, NewVtx, Template;
	local int X, Y, Idx, VertexStart;

	RotStep.Yaw = int(__NFUN_195__(float(65536), __NFUN_196__(__NFUN_196__(360, float(NumStepsPer360)), 360)));
	// End:0x50
	if(CounterClockwise)
	{
		__NFUN_178__(RotStep.Yaw, float(-1));
		__NFUN_178__(Direction, float(-1));
	}
	Idx = 0;
	VertexStart = GetVertexCount();
	vtx.X = float(InnerRadius);
	X = 0;
	J0x7B:

	// End:0x214 [Loop If]
	if(__NFUN_169__(X, 2))
	{
		NewVtx = __NFUN_241__(vtx, __NFUN_266__(RotStep, float(X)));
		vtx.Z = 0;
		// End:0xD9
		if(__NFUN_148__(SlopedCeiling, __NFUN_173__(X, 1)))
		{
			vtx.Z = float(StepHeight);
		}
		Vertex3f(NewVtx.X, NewVtx.Y, vtx.Z);
		Template[Idx].X = NewVtx.X;
		Template[Idx].Y = NewVtx.Y;
		Template[Idx].Z = vtx.Z;
		__NFUN_184__(Idx);
		vtx.Z = float(StepThickness);
		// End:0x18E
		if(__NFUN_148__(SlopedFloor, __NFUN_173__(X, 0)))
		{
			__NFUN_210__(vtx.Z, float(StepHeight));
		}
		Vertex3f(NewVtx.X, NewVtx.Y, vtx.Z);
		Template[Idx].X = NewVtx.X;
		Template[Idx].Y = NewVtx.Y;
		Template[Idx].Z = vtx.Z;
		__NFUN_184__(Idx);
		__NFUN_184__(X);
		// [Loop Continue]
		goto J0x7B;
	}
	vtx.X = float(__NFUN_165__(InnerRadius, StepWidth));
	X = 0;
	J0x233:

	// End:0x3CC [Loop If]
	if(__NFUN_169__(X, 2))
	{
		NewVtx = __NFUN_241__(vtx, __NFUN_266__(RotStep, float(X)));
		vtx.Z = 0;
		// End:0x291
		if(__NFUN_148__(SlopedCeiling, __NFUN_173__(X, 1)))
		{
			vtx.Z = float(StepHeight);
		}
		Vertex3f(NewVtx.X, NewVtx.Y, vtx.Z);
		Template[Idx].X = NewVtx.X;
		Template[Idx].Y = NewVtx.Y;
		Template[Idx].Z = vtx.Z;
		__NFUN_184__(Idx);
		vtx.Z = float(StepThickness);
		// End:0x346
		if(__NFUN_148__(SlopedFloor, __NFUN_173__(X, 0)))
		{
			__NFUN_210__(vtx.Z, float(StepHeight));
		}
		Vertex3f(NewVtx.X, NewVtx.Y, vtx.Z);
		Template[Idx].X = NewVtx.X;
		Template[Idx].Y = NewVtx.Y;
		Template[Idx].Z = vtx.Z;
		__NFUN_184__(Idx);
		__NFUN_184__(X);
		// [Loop Continue]
		goto J0x233;
	}
	X = 0;
	J0x3D3:

	// End:0x665 [Loop If]
	if(__NFUN_169__(X, __NFUN_166__(NumSteps, 1)))
	{
		// End:0x446
		if(SlopedFloor)
		{
			Poly3i(Direction, __NFUN_165__(VertexStart, 3), __NFUN_165__(VertexStart, 1), __NFUN_165__(VertexStart, 5), 'steptop');
			Poly3i(Direction, __NFUN_165__(VertexStart, 3), __NFUN_165__(VertexStart, 5), __NFUN_165__(VertexStart, 7), 'steptop');			
		}
		else
		{
			Poly4i(Direction, __NFUN_165__(VertexStart, 3), __NFUN_165__(VertexStart, 1), __NFUN_165__(VertexStart, 5), __NFUN_165__(VertexStart, 7), 'steptop');
		}
		Poly4i(Direction, __NFUN_165__(VertexStart, 0), __NFUN_165__(VertexStart, 1), __NFUN_165__(VertexStart, 3), __NFUN_165__(VertexStart, 2), 'inner');
		Poly4i(Direction, __NFUN_165__(VertexStart, 5), __NFUN_165__(VertexStart, 4), __NFUN_165__(VertexStart, 6), __NFUN_165__(VertexStart, 7), 'Outer');
		Poly4i(Direction, __NFUN_165__(VertexStart, 1), __NFUN_165__(VertexStart, 0), __NFUN_165__(VertexStart, 4), __NFUN_165__(VertexStart, 5), 'stepfront');
		Poly4i(Direction, __NFUN_165__(VertexStart, 2), __NFUN_165__(VertexStart, 3), __NFUN_165__(VertexStart, 7), __NFUN_165__(VertexStart, 6), 'stepback');
		// End:0x5A5
		if(SlopedCeiling)
		{
			Poly3i(Direction, __NFUN_165__(VertexStart, 0), __NFUN_165__(VertexStart, 2), __NFUN_165__(VertexStart, 6), 'stepbottom');
			Poly3i(Direction, __NFUN_165__(VertexStart, 0), __NFUN_165__(VertexStart, 6), __NFUN_165__(VertexStart, 4), 'stepbottom');			
		}
		else
		{
			Poly4i(Direction, __NFUN_165__(VertexStart, 0), __NFUN_165__(VertexStart, 2), __NFUN_165__(VertexStart, 6), __NFUN_165__(VertexStart, 4), 'stepbottom');
		}
		VertexStart = GetVertexCount();
		Y = 0;
		J0x5EB:

		// End:0x65B [Loop If]
		if(__NFUN_169__(Y, 8))
		{
			NewVtx = __NFUN_241__(Template[Y], __NFUN_266__(RotStep, float(__NFUN_165__(X, 1))));
			Vertex3f(NewVtx.X, NewVtx.Y, __NFUN_198__(NewVtx.Z, float(__NFUN_162__(StepHeight, __NFUN_165__(X, 1)))));
			__NFUN_184__(Y);
			// [Loop Continue]
			goto J0x5EB;
		}
		__NFUN_184__(X);
		// [Loop Continue]
		goto J0x3D3;
	}
	return;
}

function bool Build()
{
	// End:0x3A
	if(__NFUN_150__(__NFUN_150__(__NFUN_150__(__NFUN_169__(InnerRadius, 1), __NFUN_169__(StepWidth, 1)), __NFUN_169__(NumSteps, 1)), __NFUN_169__(NumStepsPer360, 3)))
	{
		return BadParameters();
	}
	BeginBrush(false, GroupName);
	BuildCurvedStair(1);
	return EndBrush();
	return;
}

defaultproperties
{
	InnerRadius=64
	StepWidth=256
	StepHeight=16
	StepThickness=32
	NumStepsPer360=8
	NumSteps=8
	GroupName=Spiral
	SlopedCeiling=true
	BitmapFilename="BBSpiralStair"
	ToolTip="Spiral Staircase"
}